# MSA 아키텍처: 트랜잭션 처리의 한계와 해결방안

---
## 목차

* [개요](#개요)
* [MSA란?](#MSA란?)
* [MSA 아키텍처에서 트랜잭션 처리의 한계](#msa-아키텍처에서-트랜잭션-처리의-한계)
  * [기존 시스템의 트랜잭션 범위](#기존-시스템의-트랜잭션-범위)
    * [1. 주문](#1-주문-)
    * [2. 결제](#2-결제)
* [해결방안](#해결방안)
  * [1. 이벤트 기반 비동기 처리](#1-이벤트-기반-비동기-처리)
  * [2. SAGA 패턴](#2-saga-패턴-)
    * [2-1. Choreography 방식](#2-1-choreography-방식)
    * [2-2. Orchestration 방식](#2-2-orchestration-방식-)
  * [3. OutBox 패턴](#3-outbox-패턴)
* [각 트랜잭션에 대한 해결방안 고려](#각-트랜잭션에-대한-해결방안-고려)
* [결론](#결론)
* [참고](#참고)

---

## 개요
- 현재 서비스의 구조는 **모놀리틱 아키텍처**로 구성되어 있습니다. 훗날 이 서비스가 확장되어 MSA 아키텍처로의 구성으로 전환이 필요해진다면, MSA 아키텍처에서 발생할 수 있는 트랜잭션의 한계와 처리 방법에 대해 설계해보는 시간을 가졌습니다.

## MSA란?
- Mircro Service Architecture
- 소프트웨어 시스템을 여러 작은 독립적인 서비스로 분할하여 개발하고 배포하는 방식
- 마이크로서비스(microservice)는 애플리케이션을 느슨하게 결합된 서비스의 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법이다.

### 장점
1. 배포
   - 각 서비스를 독립적으로 배포할 수 있어, 한 서비스의 배포 시 전체 시스템에 영향을 주지 않습니다.
   - 특정 서비스의 요구사항만 반영하여 빠르게 배포할 수 있습니다.
2. 확장
   - 특정 서비스만 별도로 수평 확장이 가능해, 필요한 부분만 효율적으로 확장할 수 있습니다.
   - 클라우드 기반 환경에 적합하여 유연한 리소스 할당이 가능합니다.
3. 장애 격리
   - 한 서비스에서 발생한 장애가 전체 시스템으로 확산될 위험이 적습니다.
   - 장애가 발생해도 해당 서비스만 격리하여 문제를 해결할 수 있습니다.
### 단점
1. 설계의 복잡성
   - MSA는 모놀리식보다 서비스 간 분리와 통신, 데이터 일관성 유지 등 설계가 복잡합니다.
2. 성능 이슈
   - 서비스 간 호출 시 API를 통한 통신으로 인한 추가 네트워크 비용과 지연(Latency)이 발생합니다.
3. 테스트 및 트랜잭션 관리
   - 각 서비스가 독립적인 DB를 사용하기 때문에, 모놀리식처럼 단일 트랜잭션으로 관리하기 어렵습니다.
   - 서비스 간의 통신이 포함되어 있어, 통합 테스트가 어려워집니다.
4. 데이터 관리의 어려움
   - 데이터가 여러 서비스에 분산되어 있어, 통합 조회나 데이터 관리가 복잡합니다.

## MSA 아키텍처에서 트랜잭션 처리의 한계
### 기존 시스템의 트랜잭션 범위
#### 1. 주문 
```
주문 TX() {
 상품 재고 확인();
 상품 재고 차감();
 쿠폰 사용 검증();
 쿠폰 사용();
 주문 정보 저장();
}
```
- 기존의 단일 트랜잭션 환경에서는 하나의 주문 처리 과정이 원자적(Atomic) 으로 수행됩니다. 모든 단계가 정상적으로 완료되어야만 트랜잭션이 성공적으로 반영됩니다.
- MSA 환경에서는 상품 서비스, 쿠폰 서비스, 주문 서비스 가 각각 독립적인 마이크로서비스로 분리되면서, 하나의 트랜잭션으로 관리하기 어려운 문제가 발생합니다.
  1) 트랜잭션의 일관성 부족
     - 상품 재고 차감 후 주문 정보 저장 전 장애가 발생하면, 재고는 감소했지만 주문이 생성되지 않는 문제가 발생할 수 있습니다. 
  2) 분산 트랜잭션 관리의 어려움
     - **상품 재고 차감 → 쿠폰 사용 → 주문 정보 저장** 과정 중 하나의 서비스에서 장애가 발생한다면 다른 서비스에서 진행된 작업을 원복(rollback)해야 하지만, MSA에서는 이를 직접 처리하기가 어렵습니다.  
  3) 네트워크 지연 및 장애 발생 가능
     - 특정 서비스가 일시적으로 다운될 경우, 전체 주문 프로세스가 중단될 가능성이 있습니다.

#### 2. 결제
```
결제 TX() {
  포인트 검증();
  포인트 차감(결제)();
  결제 정보 저장();
  주문 상태 변경();
  주문 정보 데이터플랫폼 전송();
}
```
- 결제 서비스도 주문과 마찬가지로 각 서비스가 독립적인 마이크로 서비스로 분리되면서 하나의 트랜잭션으로 관리하기 어려운 문제가 발생합니다.
  1) 결제 트랜잭션과 주문 상태 변경의 일관성 부족  
     - 포인트 차감 및 결제 저장이 성공했지만, 주문 상태 변경이 실패하면 결제된 주문이 "결제 완료" 상태로 남아 있지 않을 수 있습니다.
  2) 비즈니스 로직 간의 강한 결합
     - 결제 서비스에서 주문 상태를 변경하는 방식이 MSA 아키텍처에서 강한 결합을 유발할 수 있습니다.
- 또한, 결제 서비스의 책임은 *포인트 확인, 포인트 차감(결제), 결제 정보 저장* 으로 결제 처리를 진행하는 것 입니다.  
  *주문 정보 데이터 플랫폼 전달* 이 어떤 이유에 의해 오래 걸릴 경우 전체 트랜잭션에 영향을 끼치게 됩니다.  
  1) 부가 로직으로 인해 주요 로직이 실패할 가능성  
     - 주문 정보 데이터 플랫폼 전달 이 지연되거나 실패하면 결제 전체 트랜잭션이 실패하는 문제가 발생할 수 있습니다.
- *주문 정보 전달* 이 실패할 경우 결제 처리 전체가 실패하게 되는 문제가 있습니다.
    > 주문 정보의 전달은 **부가 로직** 이므로 **주요 로직** 인 결제 처리에 영향을 끼치면 안된다.

## 해결방안
### 1. 이벤트 기반 비동기 처리
 - 각 서비스의 기능을 이벤트 형태로 처리하여 서비스 간의 강한 결합을 줄이고 장애 영향을 최소화할 수 있습니다.
 - kafka, RabbitMQ 같은 메시지 큐를 활용하면 네트워크 지연 시에도 처리를 보장할 수 있습니다.
 - 주요 트랜잭션과 부가 로직을 분리하여 성능을 최적화할 수 있습니다.


 - **문제점**
    - 메시지 손실 가능성이 있음 → **메시지 재처리 로직 필요**
    - 장애 발생 시 이벤트가 중복 실행될 가능성이 있음 → **이중 실행 방지 로직 필요**



### 2. SAGA 패턴  
#### 2-1. Choreography 방식
 - **각 서비스가 이벤트를 주고받으며 트랜잭션을 처리하는 방식**
 - 이벤트 기반이므로 서비스 간 결합도가 낮고, 트랜잭션이 분산되어도 독립적으로 처리될 수 있습니다.


 - **장점**
    - 서비스 간 결합도 낮음 → 각 서비스가 독립적으로 이벤트를 발행하고 처리할 수 있음
    - 확장성 높음 → 새로운 서비스 추가 시, 이벤트만 구독하면 쉽게 확장 가능
    - 성능 최적화 가능 → **비동기 처리**로 인해 주요 트랜잭션과 부가적인 트랜잭션을 분리할 수 있음

 - **단점**
   - 이벤트 추적 어려움 → 각 서비스가 개별적으로 이벤트를 처리하므로, 트랜잭션 흐름을 추적하기 어려움
   - 이벤트 폭발 → 이벤트가 순차적으로 처리되므로 데이터 정합성이 실시간으로 맞지 않을 수 있음 
   - 재시도 로직 필요 → 이벤트 손실 가능성이 있어 메시지 중복 처리, 보장, 재시도 로직 추가 필요

 - 언제 사용하면 좋을까?
   - 각 서비스가 독립적이고, 느슨한 결합을 유지해야 하는 경우 
   - 트랜잭션 속도와 확장성이 중요한 경우

#### 2-2. Orchestration 방식 
 - **중앙에서 트랜잭션을 관리하는 서비스가 존재하여 순차적으로 처리하는 방식**
 - 중앙 조정자 (Orchestrator) 가 전체 트랜잭션을 관리하며, 각 서비스와 직접 통신하여 트랜잭션을 순차적으로 실행
 - 실패 시 보상 트랜잭션을 수행할 수 있도록 예외 처리가 가능합니다.
 - 트랜잭션 관리가 중앙에서 이루어져 데이터 정합성을 쉽게 유지할 수 있습니다.
   

 - **장점**
    - 트랜잭션 흐름 관리 용이 → Orchestrator 가 전체 트랜잭션을 관리하므로 이벤트 추적이 쉬움
    - 데이터 정합성 보장 가능 → 단계별로 트랜잭션을 실행하며, 실패 시 바로 감지하고 롤백 가능
    - 로직이 명확 → 서비스 간 의존성이 있지만, 트랜잭션 관리가 체계적
 - **단점**
   - Orchestrator가 단일 장애점(SPOF) → 중앙 조정자가 장애가 발생하면 전체 프로세스가 멈출 가능성이 있음
   - 네트워크 호출 오버헤드 증가 → Orchestrator가 각 서비스와 직접 통신하므로 API 호출 횟수가 많아짐
   - 확장성이 낮음 → 새로운 서비스가 추가되면, Orchestrator의 로직을 수정해야 함
 - 언제 사용하면 좋을까?
   - 데이터 정합성이 중요한 경우 (금융, 결제 등)
   - 이벤트 추적과 트랜잭션 실패 관리가 쉬운 구조가 필요한 경우

### 3. OutBox 패턴
 - 트랜잭션 로그 기반 이벤트 처리 방식. 
 - 주요 트랜잭션과 이벤트 발행을 동기적으로 저장 한 뒤, 별도의 프로세스가 이벤트를 비동기적으로 전송 하는 방식입니다.
 - 데이터 정합성을 유지하면서도 MSA 환경에서 안정적인 이벤트 기반 처리가 가능합니다.

 - **장점**
   - 데이터 정합성 보장 → 주문과 이벤트 저장이 같은 DB 트랜잭션에서 실행됨 → 데이터 손실이 없음
   - 이벤트 유실 방지 가능 → Outbox 테이블 기반으로 메시지를 저장하므로, 장애 발생 시에도 이벤트가 손실되지 않음
   - 비동기 성능 최적화 가능 → 결제 트랜잭션은 빠르게 끝내고, 이후 이벤트를 별도로 처리
 - **단점**
   - Polling 지연 가능성 → Outbox 테이블을 주기적으로 조회(Polling) 하므로 실시간 이벤트 전송이 어려울 수 있음
   - 이벤트 중복 처리 필요 → 동일 이벤트가 중복 실행될 가능성이 있어, 이중 실행 방지 로직이 필요
   - 운영 복잡성 증가 → Outbox 테이블 관리, 폴링 전략 최적화 등 추가적인 인프라 관리가 필요
 - 언제 사용하면 좋을까?
   - 이벤트 기반 시스템에서 데이터 정합성을 유지하면서 성능 최적화가 필요한 경우
   - 이벤트 유실 없이 안정적인 트랜잭션 처리가 필요한 경우

## 각 트랜잭션에 대한 해결방안 고려
### 1. 주문 트랜잭션 : `SAGA 패턴 (Choreography) + Outbox 패턴`
 - 주문은 여러 서비스(재고, 쿠폰, 주문 저장 등)와의 협업이 필요한 프로세스입니다. 
 - **서비스 간 결합도를 낮추고 확장성을 높여야 하기 때문에** 이벤트 기반의 트랜잭션이 적합하다고 판단하였습니다.
 - 또한, 트랜잭션의 속도가 중요하므로 비동기 방식이 유리합니다.  


 - **Choreography 기반의 SAGA 패턴**은 MSA 확장성이 뛰어나 OrderService 를 변경하지 않고 새로운 서비스를 쉽게 추가할 수 있습니다. 또한, ProductService, CouponService 가 병렬로 실행되어 주문 속도를 빠르게 유지할 수 있으며, **Outbox 패턴**을 통해 이벤트 손실 없이 안정적으로 트랜잭션을 유지할 수 있습니다.




 - 시퀀스 다이어그램
    ```mermaid
    sequenceDiagram
        participant User
        participant OrderService
        participant Outbox
        participant EventPublisher
        participant ProductService
        participant CouponService
    
        User->>OrderService: 주문 요청 
        OrderService->>Outbox: 주문 데이터 & 이벤트 저장
        OrderService-->>User: 주문 요청 성공 응답
    
        Note over EventPublisher: Outbox 테이블 Polling 후 이벤트 발행
        EventPublisher->>ProductService: "OrderCreated" Event
        EventPublisher->>CouponService: "OrderCreated" Event
    
        Note over ProductService, CouponService: 서비스별 비동기 처리
        ProductService->>ProductService: 재고 차감
        CouponService->>CouponService: 쿠폰 사용 처리
 1. 사용자가 주문 요청 전송
    - 사용자는 API를 호출하여 특정 상품에 대한 주문을 요청
 2. OrderService 가 주문 정보를 데이터베이스에 저장 
    - 주문을 생성하면서, Outbox 에도 주문 이벤트를 함께 저장
    - 하나의 DB 트랜잭션으로 실행 → **데이터 정합성 보장**
 3. OrderService 가 주문 성공 응답을 반환
    - 사용자는 주문 응답 즉시 확인 가능 
    - 비동기 이벤트 처리는 이후 별도 진행
 4. Event Publisher 가 Outbox 를 주기적으로 조회 (Polling)
    - Outbox 에서 "아직 발행되지 않은 이벤트" 를 찾아서 가져옴 
 5. 이벤트 발행기가 ProductService, CouponService 에 이벤트 전송
    - 주문이 생성되었음을 알리는 이벤트 전송 
    - 비동기적으로 실행 → 이벤트가 전송되더라도 **주문 처리는 영향을 받지 않음**  
 6. ProductService 가 "OrderCreated" 이벤트를 수신하고 재고 차감 실행
 7. CouponService 가 "OrderCreated" 이벤트를 수신하고 쿠폰 사용 처리

### 2. 결제 트랜잭션 : `SAGA 패턴 (Orchestration) + 보상 트랜잭션`
 - 결제는 **데이터의 정합성**이 굉장히 중요한 트랜잭션으로 모든 단계가 동기적으로 처리 되어야 합니다.
 - `잔액 차감 → 결제 저장 → 주문 상태 변경` 의 순차적 처리가 중요하고, 결제 도중 장애 발생 시 보상 트랜잭션(환불)이 필요합니다.


 - **Orchestration 기반의 SAGA 패턴**은 중앙 PaymentOrchestrator 가 각 단계를 순차적으로 진행하며 트랜잭션을 관리하며 하나라도 실패하면 보상 트랜잭션을 통해 결제를 롤백할 수 있습니다. 
 - Choreography 방식은 이벤트를 기다려야 하지만 **Orchestration 방식은 즉시 실패 감지 후 롤백 수행이 가능합니다.**


 - 시퀀스 다이어그램
    ```mermaid
    sequenceDiagram
        participant User
        participant PaymentOrchestrator
        participant UserService
        participant PaymentService
        participant OrderService
        participant CompensationHandler
    
        User->>PaymentOrchestrator: 결제 요청 (PaymentCommand)
    
        Note over PaymentOrchestrator: (1) 잔액 확인 및 차감
        PaymentOrchestrator->>UserService: useBalance(userId, payAmount)
        UserService-->>PaymentOrchestrator: 차감 완료
    
        Note over PaymentOrchestrator: (2) 결제 정보 저장
        PaymentOrchestrator->>PaymentService: pay(orderId, payAmount)
        PaymentService-->>PaymentOrchestrator: 결제 성공
    
        Note over PaymentOrchestrator: (3) 주문 상태 변경
        PaymentOrchestrator->>OrderService: completeOrder(orderId)
        OrderService--X PaymentOrchestrator: 주문 상태 변경 실패!
    
        Note over CompensationHandler: (4) 보상 트랜잭션 수행
        CompensationHandler->>PaymentService: 결제 취소
        PaymentService->>UserService: 환불 (restoreBalance)
    
        PaymentOrchestrator-->>User: 결제 실패 응답

1. 잔액 확인 및 차감
   - 사용자가 PaymentCommand 를 전송하여 결제 요청
   - **PaymentOrchestrator** 가 UserService 에 잔액 차감 요청
   - 잔액이 부족할 경우, 예외를 발생시켜 **트랜잭션 중단**. 잔액이 충분하면 차감 후 다음 단계로 진행

2. 결제 정보 저장
   - **PaymentOrchestrator** 가 PaymentService 에 결제 정보 저장 요청
   - pay(orderId, payAmount) 호출
   - PaymentService 가 결제 정보를 저장하고 성공 응답 반환
   - 결제가 성공적으로 이루어지면, 다음 단계로 진행
        
3. 주문 상태 변경 요청 → 실패 발생
   - **PaymentOrchestrator** 가 OrderService 에 주문 상태 변경 요청 (completeOrder(orderId))
   - OrderService 에서 장애가 발생하게 되면 이로 인해 트랜잭션 실패 발생
   > 이 단계에서 오류가 발생하면, 결제는 이미 완료되었지만 주문이 정상적으로 반영되지 않음.   
   > 따라서 이전 단계(결제, 잔액 차감) 를 롤백해야 함.

4. 보상 트랜잭션 실행
   - CompensationHandler 가 보상 트랜잭션 수행 
   - PaymentService 에 결제 취소 요청
   - PaymentService 가 결제를 취소하고, UserService 에게 잔액 환불 요청
   - UserService 가 사용자의 원래 잔액을 복구
   - **PaymentOrchestrator** 가 사용자에게 결제 실패 응답 반환




## 결론
서비스의 확장을 위해서는 모놀리틱 아키텍처에서 MSA로의 전환이 필요할 수 있습니다. 하지만 MSA 구조에서는 기존의 단일 트랜잭션 방식이 적용되기 어려워지면서 **분산 트랜잭션 관리의 한계**가 발생하게 됩니다. 
이번 보고서에서는 MSA에서 발생할 수 있는 트랜잭션의 한계와 그에 대한 해결 방안을 분석하고, 각 방안의 장단점을 비교하였습니다.  
또한, 해결 방안 중 각 트랜잭션에 적합한 방안을 채택하여 설계하는 시간을 가졌습니다. 트랜잭션을 분리하는 과정에서 데이터의 정합성을 보장하기 위해 동기적으로 실행해야 할 작업과 비동기적으로 실행되어야 할 작업을 구분하며 그에 따른 적합한 패턴을 고려해보았습니다.    

MSA 환경에서 안정적인 서비스 운영을 위해서는 각 서비스가 독립성을 유지하면서도 전체적인 데이터 일관성을 보장할 수 있도록 아키텍처를 설계해야겠습니다.

---
## 참고
- [MSA란?](https://hahahoho5915.tistory.com/71)
- [[MSA 패턴] SAGA, Transactional Outbox 패턴 활용하기](https://devocean.sk.com/blog/techBoardDetail.do?ID=165445)
- [트랜잭셔널 아웃박스 패턴의 실제 구현 사례](https://medium.com/@greg.shiny82/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90-%EC%95%84%EC%9B%83%EB%B0%95%EC%8A%A4-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84-%EC%82%AC%EB%A1%80-29cm-0f822fc23edb)


